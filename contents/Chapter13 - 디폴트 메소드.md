> 자바 8에서는 기본 구현을 포함하는 인터페이스를 정의하는 두 가지 방법을 제공한다.
- 인터페이스 내부에 정적 메소드를 사용하는 것
- 인터페이스의 기본 구현을 제공할 수 있도록 디폴트 메소드 기능을 사용하는 것

> 즉, 자바 8에서는 메소드 구현을 포함하는 인터페이스를 정의할 수 있다. 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로 
> 인터페이스에 추가된 새로운 메서드의 디폴트 메서드를 상속받게 된다. 이렇게 하면 기존의 코드 구현을 바꾸도록 강요하지 않으면서도 
> 인터페이스를 바꿀 수 있다.

### 호환성
> 자바 프로그램을 바꾸는 것과 관련된 호환성 문제는 크게 바이너리 호환성, 소스 호환성, 동작 호환성 세 가지로 분류할 수 있다.
- 바이너리 호환성 : 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황
  - 인터페이스에 메소드를 추가했을 때 추가된 메소드를 호출하지 않는 한 문제가 일어나지 않음
- 소스 호환성 : 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있는 상황
  - 인터페이스에 메소드를 추가하면 소스 호환성이 아니다. 추가한 메소드를 구현하도록 클래스를 고쳐야 하기 때문
- 동작 호환성 : 코드를 바꾼 다음에도 같은 입력값이 주어지면 프로그램이 같은 동작을 실행하는 상황
  - 인터페이스에 메소드를 추가하더라도 프로그램에서 추가된 메소드를 호출할 일은 없으므로 동작 호환성은 유지된다.

## 디폴트 메소드
> 자바 8에서는 호환성을 유지하면서 API를 바꿀 수 있도록 새로운 기능인 디폴트 메소드를 제공한다. 이제 인터페이스는 자신을 구현하는
> 클래스에서 메소드를 구현하지 않을 수 있는 새로운 메소드 시그니처를 제공한다. 디폴트 메소드는 default라는 키워도로 시작하며 다른 
> 클래스에 선언된 메소드처럼 메소드 바디를 포함한다.

### 추상클래스와 자바 8의 인터페이스
> 그렇다면 둘 다 추상 메소드와 바디를 포함하는 메소드를 정의할 수 있는 추상 클래스와 인터페이스는 뭐가 다를까?
- 클래스는 하나의 추상 클래스만 상속받을 수 있지만 인터페이스를 여러 개 구현할 수 있다.
- 추상 클래스는 인스턴스 변수(필드)로 공통 상태를 가질 수 있다. 하지만 인터페이스는 인스턴스 변수를 가질 수 없다.

## 디폴트 메소들 활용 패턴
### 선택형 메소드
> 자바 8 이전에는 잘 사용하지 않는 기능을 빈 구현으로 사용했다. 디폴트 메소드를 이용하면 기본 구현을 제공할 수 있으므로 
> 인터페이스를 구현하는 클래스에서 빈 구현을 제공할 필요가 없다. 따라서 구현할 필요가 없어졌고 불필요한 코드를 줄일 수 있게 되었다.
### 동작 다중 상속
> 디폴트 메소드를 이용하면 기존에는 불가능했던 동작 다중 상속 기능도 구현할 수 있다. 중복되지 않는 최소한의 인터페이스를 유지한다면
> 우리 코드에서 동작을 쉽게 재사용하고 조합할 수 있다.

## 해석 규칙
> 자바의 클래스는 하나의 부모 클래스만 상속받을 수 있지만 여러 인터페이스를 동시에 구현할 수 있다. 자바 8에는 디폴트 메소드가 
> 추가되었으므로 같은 시그니처를 갖는 디폴트 메소드를 상속받는 상황이 생길 수 있다. 자바 8은 이러한 문제에 대한 해결 규칙을 제공한다.

- 클래스나 슈퍼클래스에서 정의한 메소드가 디폴트 메소드보다 우선권을 갖는다.
- 1번 규칙 이외의 상황에서는 서브 인터페이스가 이긴다. 상속관계를 갖는 인터페이스에서 같은 시그니처를 갖는 메소드를 정의할 때는 서브 인터페이스가 이긴다.
- 여전히 디폴트 메소드의 우선순위가 결정되지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메소드를 오버라이드하고 호출해야 한다.

### 디폴트 메소드를 제공하는 서브 인터페이스가 이긴다.
![image](https://user-images.githubusercontent.com/80659375/218055498-ace171ee-cebe-418f-b582-72d20bafb900.png)
> B와 A는 hello라는 디폴트 메소드를 정의했고, B는 A를 상속받는다. 이러한 경우 2번 규칙 서브 인터페이스가 이긴다 즉, B가 A를 상속받았으므로 컴파일러는 B의 hello를 
> 선택한다.

![image](https://user-images.githubusercontent.com/80659375/218055987-8cf49ad4-9605-4c7f-bdd0-44f9f85757fb.png)
> 1번 규칙은 클래스의 메소드 구현이 이긴다고 설명한다. 하지만 클래스 D는 hello를 오버라이드하지 않았고 단순히 인터페이스 A를 구현했다. 따라서 D는 A의 디폴트 메소드
> 구현을 상속받는다. 2번 규칙에서는 클래스나 슈퍼클래스에 메소드 정의가 없을 때는 디폴트 메소드를 정의하는 서브 인터페이스가 선택되므로 인터페이스 A의 hello와 인터페이스
> B의 hello 둘 중 하나를 선택하게 되어 위와 동일하게 B의 hello를 선택한다.

### 충돌 그리고 명시적인 문제 해결
![image](https://user-images.githubusercontent.com/80659375/218068693-3bd74cac-59f7-4704-90b8-eabd3a67ccd3.png)
> 지금까지의 예시는 1번, 2번 규칙으로 문제를 해결할 수 있었다. 그러나 이번에는 인터페이스 간에 상속 관계가 없으므로 2번 규칙을 적용할 수 없다. 구별할 기준이 없기 때문에
> 자바 컴파일러가 어떤 메소드를 호출해야 할지 알 수 없어 에러를 발생시킨다.

### 충돌 해결
```java
public class C implements B, A {
	void hello() {
		B.super.hello();
	}
}
```
> 이런 상황에서는 개발자가 직접 클래스 C에서 사용하려는 메소드를 명시적으로 선택해야 한다. 즉, 클래스 C에서 hello 메소드를 오버라이드한 다음에 호출하려는 메소드를 명시적으로
> 선택해야 한다. 자바 8에서는 X.super.m(...) 형태의 새로운 문법을 제공하고 있고 X는 호출하려는 메소드 m의 슈퍼인터페이스이다.

### 다이아몬드 문제
```java
public interface A {
	default void hello() { ... }
}

public interface B extends A { }
public interface C extends A { }

public class D implements B, C { 
	public static void main(String... args) {
		new D().hello();
	}
}
```
![image](https://user-images.githubusercontent.com/80659375/218070249-ac0ddd58-ff00-480c-968c-7120877798b1.png)
> 이 그림과 같은 구조를 다이아몬드 문제라고 부른다. D는 B와 C중 누구의 디폴트 메소드 정의를 상속받아야 할까. 실제로 선택할 수 있는 메소드 선언은 A의 디폴트 메소드 이기 
> 때문에 A의 hello가 호출 될 것이다.

> 만약 B에도 같은 시그니처의 디폴트 메소드 hello가 있다면 어떻게 될까. 2번 규칙에 따르면 디폴트 메소드를 제공하는 가장 하위의 인터페이스가 선택된다고 했고 B는 A를
> 상속 받으므로 B가 선택 될것이다. 만약 B와 C가 모두 디폴트 메소드 hello를 정의했다면 충돌이 발생하므로 이전에 설명한 것처럼 둘 중 하나의 메소드를 명시적으로 호출 해야한다.

> 그렇다면 다음처럼 인터페이스 C에 추상 메소드 hello를 추가하면 어떤 일이 벌어질까?
```java
public interface C extends A {
	void hello();
}
```
> C는 A를 상속받으므로 C의 추상 메소드 hello가 A의 디폴트 메소드 hello보다 우선권을 갖는다. 따라서 컴파일 에러가 발생하게 된다.

## 마치며
- 자바 8의 인터페이스는 구현 코드를 포함하는 디폴트 메소드, 정적 메소드를 정의할 수 있다.
- 디폴트 메소드의 정의는 default 키워드로 시작하며 일반 클래스 메소드처럼 바디를 갖는다.
- 공개된 인터페이스에 추상 메소드를 추가하면 소스 호환성이 깨진다.
- 디폴트 메소드 덕분에 라이브러리 설계자가 API를 바꿔도 기존 버전과 호환성을 유지할 수 있다.
- 선택형 메소드와 동작 다중 상속에도 디폴트 메소드를 사용할 수 있다.
- 클래스가 같은 시그니처를 갖는 여러 디폴트 메소드를 상속하면서 생기는 충돌 문제를 해결하는 규칙이 있다.
- 클래스나 슈퍼클래스에 정의된 메소드가 다른 디폴트 메소드 정의보다 우선한다. 이 외의 상황에서는 서브 인터페이스에서 제공하는 디폴트 메소드가 선택된다.
- 두 메소드의 시그니처가 같고, 상속관계로도 충돌 문제를 해결할 수 없을 때는 디폴트 메소드를 사용하는 클래스에서 메소드를 오버라이드해서 어떤 디폴트 메소드를 호출할지 명시적으로 결정해야 한다.
