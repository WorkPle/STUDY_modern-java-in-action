
# 스트림 소개
> 스트림 api가 나오기 전 자바에서는 많은 요소를 포함하는 커다란 컬렉션을 사용해 저장된 데이터에 접근하기 위해서 매번 for문 또는 iterator를 사용하여 다루었다. 
하지만 이렇게 작성된 코드는 가독성도 떨어지며 재사용이 용이하지 않았다. 
이러한 문제를 해결할 수 있고 병렬성 처리마저 쉽게 할 수 있게 만든 것이 스트림api다.
> 

## 스트림이란 무엇인가?

- 자바 8 API에 새로 추가된 기능이다.
- 선언형으로(질의 표현으로) 컬렉션 데이터를 처리할 수 있다.
- 데이터를 병렬로 처리할 수 있다

### 스트림이 주는 이득

- 선언형 : 더 간결하고 가독성이 좋아진다.
- 조립할 수 있음 : 유연성이 좋아진다.
- 병렬화 : 성능이 좋아진다.

### 스트림의 정의

스트림의 정의 : ‘**데이터 처리 연산**을 지원하도록 **소스**에서 추출된 **연속된 요소**’ 

- 연속된 요소
    - 컬렉션과 마찬가지로 스트림은 특정 요소형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다
        - 컬렉션은 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다 (데이터 중점)
        - 스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룬다 (계산 중점)
- 소스
    - 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다 
    정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
- 데이터 처리 연산
    - 스트림은 함수형 프로그래밍과 및 데이터 베이스와 비슷한 연산을 지원한다. 
    스트림 연산은 순차적으로 또는 병렬로 실행할 수 있다.
- 파이프 라이닝
    - 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림 자신을 반환한다. (덕분에 laziness, short-circuiting같은 최적화도 얻을 수 있다)
- 내부 반복
    - 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부반복을 지원한다.

### 예시

```java
List<String> threeHighCaloricDishNames = 
	menu.stream()
			.filter(dish -> dish.getCalorie() > 300)
			.map(Dish::getName)
			.limit(3)
			.collect(toList());
```

- 데이터 소스 : menu
- 연속된 요소 : menu.stream()
- 데이터 처리 연산 : filter, map, limit, collect
    - 데이터 처리 연산
        - filter: 람다를 인수로 받아 스트림에서 특정 요소를 제외시킨다
        - map: 람다를 이용해서 한 요소를 다른 요소로 변환하거나 정보를 추출한다.
        - limit: 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림 크기를 축소 한다.
        - collect: 스트림을 다른 형식으로 변환한다.
- 파이프 라인: collect를 제외한 모든 연산은 서로 파이프 라인을 형성할 수 있도록 스트림을 반환한다

→ 마지막으로 collect 연산으로 파이프 라인을 처리해 결과를 반환한다 (collect는 스트림이 아닌 list를 반환)

## 스트림과 컬렉션

### 스트림과 컬렉션의 차이

1. 데이터를 언제 계산하는지
    - **컬렉션**은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조이다.
        - 즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다.
    - **스트림**은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조다
        - 스트림은 게으르게 만들어지는 컬렉션과 같다 (즉, 사용자가 데이터를 요청할 때만 값을 계산한다)
2. 탐색
- 컬렉션은 반복 사용할 수 있는 데이터 소스이다
- 스트림은 딱 한번만 탐색할 수 있다.
    
    ```java
    List<String> title = Arrays.asList("seo", "ye", "won");
    Stream<String> s = title.stream();
    s.forEach(System.out::println);
    s.forEach(System.out::println); // java.lang.IllegalStateException : 스트림이 이미 소비되었거나 닫힘
    ```
    
    - 탐색된 스트림의 요소는 소비되며, 반복자(for)와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.
1. 데이터 반복 처리 방법
- 외부 반복(사용자가 직접 요소를 반복한다. for-each)
    - **컬렉션**은 외부적으로 반복한다
    - 즉, 명시적으로 컬렉션 항목을 하나씩 가져와서 처리한다.
    - 병렬성을 스스로 관리해야 한다
- 내부 반복(반복을 알아서 처리하고 결과 스트림값을 어딘가에 저장해준다)
    - **스트림**은 내부적으로 반복한다
    - 작업을 병렬로 처리(자동)하거나 더 최적화 된 다양한 순서로 처리할 수 있다.

## 스트림 연산

스트림 연산은 연결할 수 있는 스트림 연산을 뜻하는 중간연산과
스트림을 닫는 연산을 뜻하는 최종연산 두가지로 구분 할 수 있다. 

![스크린샷 2023-01-01 오후 12.58.15.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6eccb4c3-3f9e-46a3-a1a0-c4a0a06600bf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.58.15.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230103%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230103T153200Z&X-Amz-Expires=86400&X-Amz-Signature=60d4de90ce2d2fedaf92b97a8c85d6f8ab8145350d4152ac18040c0d9be4f37f&X-Amz-SignedHeaders=host&response-content-disposition=filename%3D%22%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA%25202023-01-01%2520%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE%252012.58.15.png%22&x-id=GetObject)

### 중간 연산

| 연산 | 형식 | 반환형식 | 연산의 인수 | 함수 디스크립터 |
| --- | --- | --- | --- | --- |
| filter | 중간연산 | Stream<T> | Predicate<T> | T → boolean |
| map | 중간연산 | Stream<R>
R: 새 스트림의 요소 유형 | Function<T,R> | T → R |
| limit | 중간연산 | Stream<T> |  |  |
| sorted | 중간연산 | Stream<T> | Comparator<T> | (T, T) → int |
| distint | 중간연산 | Stream<T> |  |  |
- filter나 sorted같은 중간 연산은 다른 스트림을 반환한다.
- 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다.
- 단말 연산을 스트림 파이프라인에 실행하기 전 까지는(최종 연산 전까지는) 아무 연산도 수행하지 않는다
    - 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한번에 처리하기 때문이다
    - 이런 특성(lazy)을 통해 최적화 효과를 얻을 수 있다
        - 쇼트 서킷(limit)
            
            조건문에서 여러 개의 조건을 중첩할 때, && 연산자와 II 연산자는 참 거짓이 확정되면 뒤의 조건은 검사하지 않는다.
            
        - 루프 퓨전(filter, map)
            
            프로그래밍 효율성 또는 컴파일러 최적화 원칙에 따라 둘 이상의 루프를 하나로 결합하는 프로그래밍 기술 유형
            

### 최종 연산

| 연산 | 형식 | 반환형식 | 목적 |
| --- | --- | --- | --- |
| forEach | 최종 연산 | void | 스트림의 각 요소를 소비하면서 람다를 적용한다 |
| count | 최종 연산 | long
(generic) | 스트림의 요소 개수를 반환한다 |
| collect | 최종 연산 |  | 스트림을 리듀스 해서 리스트, 맵, 정수 형식의 컬렉션을 만든다 |
- 스트림 파이프라인에서 결과를 도출한다

### 스트림 이용 과정 요약

> *스트림 파이프 라인의 개념은 빌더 패턴과 비슷하다*
> 
- 질의를 수행할 (컬렉션 같은) 데이터 소스
- 스트림 파이프 라인을 구성할 중간 연산 연결
- 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

### 스트림의 특징

- **람다 표현식**
    
    스트림은 **람다식으로 요소 처리 코드**를 제공한다
    
- **중간연산, 최종연산**
- **재사용 불가능**
    
    스트림은 생성되고, 중간처리를 거쳐 최종처리까지 완료되면 닫히게된다. 
    이미 닫힌 스트림은 재사용할 수 없으며, 재사용을 시도할 경우 예외가 발생한다. **즉 스트림은 일회용이다.**
    
- **원본 데이터를 변경하지 않는다**
    
    스트림은 원본 객체의 값을 사용하기만 할 뿐 변경하지 않는다. 
    스트림은 최종 처리를 통해 원본과 무관한 새로운 객체를 생성한다.
    

참고: 모던자바 인 액션

[Stream (Java Platform SE 8 )](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)

[[Java] Stream 개념](https://hudi.blog/java-stream/)
